package main

import (
	"fmt"
	"time"
	"runtime"
)

/*
	进程:
		1.进程是程序（编译后的二进制文件）在操作系统中的一次执行过程；
		2.代码逻辑 + 系统分配资源的统称；
		3.是系统进行资源分配和调度的基本单位。
	进程状态:
		1.初始态: 进程准备状态（可进入就绪态）；
		2.就绪态: 等待CPU分配时间片（能够进入运行态和停止态）；
		3.运行态: 占用CPU进行逻辑计算（能进入就绪态，停止态和阻塞态）；
		4.阻塞态: 等待CPU以外的其他资源（如io操作），主动放弃CPU（能进入停止态和就绪态）；
		5.终止态: 进程结束状态。
	线程:
		1.线程是进程的一个执行实例，是程序执行的最小单元；
		2.是程序中的一条逻辑执行路径。
	线程同步机制:
		1.互斥锁: 线程拿到锁后，才能访问数据，没有拿到锁的线程阻塞等待，等拿到锁的线程释放锁；
		2.读写锁: 一把锁具有读属性或写属性，写锁独占，读锁共享，写锁优先级高。
	并发:
		1.多任务的程序在单核上运行；
		2.在一块CPU上有多个任务进行轮询操作，每个任务执行很短的时间；
		3.因为CPU处理速度非常快，就好像多个任务同时执行，实际上某一时间点只有一个任务执行。
	并行:
		1.多任务的程序在多核上运行；
		2.在多块CPU上运行同等数量的任务，每个任务都由各自的CPU执行；
		3.在任何时间点上，都有多个任务同时执行。
	Go协程特点:
		1.有独立的栈空间；
		2.共享程序的堆空间；
		3.调度由程序员控制；
		4.在一个线程中可以存在多个协程；
		5.非抢占式多任务处理，由协程主动交出控制权；
		6.编译器/解释器/虚拟机层面的多任务。
	Goroutine可能切换的条件（具体何时切换由goroutine调度器决定）:
		1.i/o操作，select调度；
		2.channel管道；
		3.等待锁；
		4.函数调用是切换的机会；
		5.runtime.Gosched()。
	MPG模式:
		M: 代表真正的内核OS线程；
		G: 代表一个goroutine，存在自己的栈，用于调度；
		P: 代表调度的上下文，可以看做是一个局部的调度器。
	goroutine与线程：
		1.栈：
			1.1 每个OS线程都有一个固定大小的栈内存（通常2MB），这块区域用来保存其他函数调用期间那些正在执行或临时暂停的函数中的局部变量；
			1.2 goroutine在声明周期开始时有一个很小的栈（通常2KB），goroutine的栈也用于存放那些正在执行或临时暂停的函数中的变量。
				但goroutine的栈不固定，可以按需增大和缩小。
		2.调度：
			2.1 线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用调度器（一个内核函数）；
				函数暂停当前运行的线程，并将它的寄存器信息保存到内存，之后查看线程列表决定接下来运行哪一个线程，再从内存恢复线程的注册表信息，最后继续执行选中的线程；
				因为由内核调度，所以控制权限从一个线程到另一个线程需要完整的上下文切换：即保存一个线程的状态到内存，再恢复另一个线程的状态，最后更新调度器结构。
			2.2 Go运行时有自己的调度器（m:n调度技术，可以复用/调度m个goroutine到n个线程），该调度器只需要关心单个Go程序的goroutine调度问题；
				Go调度器由特定的Go语言结构来触发，如：当一个goroutine调用time.Sleep或被channel阻塞或lock操作时，调度器就会将该goroutine设为休眠并运行其他goroutine直到前一个可唤醒。
		3.标识：
			2.1 线程大部分都有一个独特的标识，通常是整数或指针，以这个特征可以构建一个线程的局部存储；
				本质上是一个全局map，以线程标识为键，使每个线程都可以独立地用这个map存储获取值，而不受其他线程干扰。
			2.2 goroutine没有可供程序员访问的标识。
*/

// 主go程开始作用在当前进程的主线程上，主线程是一个物理线程，直接作用在CPU上，重量级资源消耗大
func main() {
	// NumCPU(): 获取本机的CPU核数
	num := runtime.NumCPU()
	fmt.Printf("CPU个数: %v\n", num)


	/*
		1.runtime.GOMAXPROCS(): 设置用来并行计算的CPU核数的最大值，返回上一次设置的最大值；
		2.GOMAXPROCS参数用来确定需要使用多少个线程来同时执行Go代码，默认是机器上的CPU数量；
		3.正在休眠或正在被channel通信阻塞的goroutine不需要占用线程；
		4.阻塞在I/O和其他系统调用中或调用非Go语言写的函数的goroutine需要独立的OS线程，但这个线程不计算在GOMAXPROCS内。
	*/
	max := runtime.GOMAXPROCS(num)
	fmt.Printf("上一次设置的CPU核数最大值: %v\n", max)
	
	/*
		1.由主go程开启的程序执行的分支路径；
		2.go程是轻量级线程，是由编译器优化的逻辑态，资源消耗相对小。
	*/
	go func() {
		for i := 0; i < 10; i++ {
			// 在遇到io操作的时候，程序可能会在适当的时候阻塞，阻塞时go程会让出控制权
			fmt.Printf("test() 执行 %v次\n", i)
			if i == 5 {
				// Gosched(): 让出当前go程所占用的cpu时间片，当再次获得cpu时，从出让位置继续回复执行
				runtime.Gosched()
			} else if i == 8 {
				// Goexit(): 结束当前go程，执行所有defer
				runtime.Goexit()
			}
		}
	}()
	
	var arr [10]int
	for i := 0; i < 10; i++ {
		go func(i int) {
			for {
				// 此项操作会让go程不知道何时让出控制权，会死在for{}循环中
				arr[i]++
				// 使用runtime.Gosched()手动让出控制权
				runtime.Gosched()
			}
		}(i)
	}

	// 主线程执行结束会直接退出程序（不管其他协程分支）
	for i := 0; i < 10; i++ {
		fmt.Printf("main() 执行 %v次\n", i)
		time.Sleep(time.Second)
	}

	fmt.Println(arr)
}