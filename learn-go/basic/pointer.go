package main

import "fmt"

/* 指针 */

/*
	内存布局(32位操作系统为例，最大内存4G): 
	1.Kernel(内核态):
		1.1 占用1G空间
		1.2 操作系统，驱动，进程管理
	2.User(用户态): 
		RO(只读属性)
		1.1 .text(代码区)
		1.2 .rodata(只读数据区)
		RW(读写属性)
		1.3 .data(数据区): 保存初始化完的全局变量
		1.4 .bss(未初始化的数据区)
		1.5 .heap(堆区): 需要GC垃圾回收机制释放内存
		1.6 共享数据区
		1.7 .stack(栈区): 操作系统自动释放
	3.栈帧:
		3.1 给函数运行提供内存空间，在栈空间中分配；
		3.2 当函数调用时产生栈帧，函数调用结束释放栈帧；
		3.3 栈帧存储局部变量，形参和内存字段描述值(存储栈基栈顶指针的位置)；
		3.4 栈空间存在栈顶指针和栈基指针（开始时栈顶栈基指针重合），当函数调用并在栈区分配空间时，
			栈顶指针后移，此时栈基指针和栈顶指针的距离就是该函数的栈帧空间；
		3.5 当函数调用其他函数，会在栈空间新分配一段栈帧，此时栈基栈顶指针都会移动到被调用函数的内存位置，
			由调用方函数记录自己的栈基栈顶指针位置(由内存字段描述值存储)，当被调用函数执行完毕释放后，根据此位置重新将指针移动。
*/
func main() {
	// 空指针就是指未被初始化的指针
	var p *int
	fmt.Printf("%v\n", p)

	// 野指针是指被一片无效的地址空间初始化的指针
	// var f *int = 0
	// fmt.Printf("%v\n", *f)

	// new()函数: 在堆内存上申请一段指定类型的内存空间，返回的是这段空间的首地址
	a := 123
	p = new(int)
	p = &a	// & 表示取变量地址
	fmt.Printf("%T, %v\n", p, p)
	fmt.Printf("%T, %v\n", *p, *p)	// *指针 表示取指针指向的内容
}