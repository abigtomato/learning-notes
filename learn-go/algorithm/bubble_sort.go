package main

import "fmt"

/*
	冒泡排序

	初始状态:
		[24, 69, 80, 57, 13]
	第1轮排序:
		第1次比较: [24, 69, 80, 57, 13]
		第2次比较: [24, 69, 80, 57, 13]
		第3次比较: [24, 69, 57, 80, 13]
		第4次比较: [24, 69, 57, 13, 80]
	第2轮排序:
		第1次比较: [24, 69, 57, 13, 80]
		第2次比较: [24, 57, 69, 13, 80]
		第3次比较: [24, 57, 13, 69, 80]
	第3轮排序:
		第1次比较: [24, 57, 13, 69, 80]
		第2次比较: [24, 13, 57, 69, 13]
	第4轮排序:
		第1次比较: [13, 24, 57, 69, 80]
	分析:
		1. 共进行4轮排序，由此得出外层循环次数为len(arr) - 1
		2. 每轮排序确定一个数的位置，越往后单轮排序内的比较次数越少，由此判断内层循环次数根据外层循环次数递减
		3. 每次都要比较本次循环到的元素和后一位元素的大小，依据情况判断是否交换
 */
func BubbleSort001(data []int) {
	// 外层控制总排序次数
	for i := 0; i < len(data) - 1; i++ {
		// 1. 内层控制一轮相邻数据比较
		// 2. 相邻数据比较，大的向后移，每次内层for都会在尾部确定一个数
		for j := 0; j < len(data) - 1 - i; j++ {
			// 交互数据
			if data[j] > data[j + 1] {
				data[j], data[j + 1] = data[j + 1], data[j]
			}
		}
	}
}

func BubbleSort002(data []int) {
	for i := 0; i < len(data) - 1; i++ {
		for j := 0; j < len(data) - 1 - i; j++ {
			if data[j] > data[j + 1] {
				data[j], data[j + 1] = data[j + 1], data[j]
			}
		}
	}
}

func main() {
	data := []int{2, 1, 6, 8, 3, 5, 9, 4, 7}
	BubbleSort001(data)
	BubbleSort002(data)
	fmt.Println(data)
}
