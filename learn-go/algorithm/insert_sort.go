package main

import "fmt"

/*
	插入排序

	初始状态:
		原始表: [23, 0, 12, 56, 34]
		有序表: [23]
		无序表: {0, 12, 56, 34}
	第一次找到插入位置:
		[23, 0] {12, 56, 34}
	第二次找到插入位置:
		[23, 0, 0] {56, 34}	insertVal = 12
		[23, 12, 0]	{56, 34}
	第三次找到插入位置:
		[23, 12, 0, 0] {34} insertVal = 56
		[23, 12, 12, 0] {34} insertVal = 56
		[23, 23, 12, 0] {34} insertVal = 56
		[56, 23, 12, 0] {34}
	第四次找到插入位置:
	 	[56, 23, 12, 0, 0] insertVal = 34
	 	[56, 23, 12, 12, 0] insertVal = 34
	 	[56, 23, 23, 12, 0] insertVal = 34
	 	[56, 34, 23, 12, 0]
	分析:
		1. 把n个待排序的元素看成一个有序表和一个无序表
		2. 有序表开始时只有一个元素，默认是取n个元素的第一个(下标为0)
		3. 无序表开始时有n-1个元素，除第一个元素外的所有元素
		4. 排序过程中每次从无序表中取出第一个元素，把它与有序表元素进行比较，将它插入有序表的适当位置，成为新的有序表
 */
func InsertSort001(data []int) {
	// 1. 外层for从1号元素开始，0号元素默认为有序表
	// 2. 外层for控制的是无序表中的元素(默认0构成有序表，其他元素构成无序表)
	for i := 1; i < len(data); i++ {
		// 1. 若无序表第一个元素小于有序表最后一个元素，则将该无序数据插入有序表合适的位置
		// 2. 无序表第一个元素和有序表最后一个元素相邻
		if data[i] < data[i - 1] {
			// 指向有序表最后一个元素
			j := i - 1
			// 需要插入有序表的无序元素
			elem := data[i]

			// 内层循环从尾部向前遍历有序表，找到适合无序元素的位置
			for j >= 0 && data[j] > elem {
				// 元素向后移动，为要插入的元素空出位置
				data[j + 1] = data[j]
				// 指针向前移动
				j--
			}

			// 若上面的循环跳出，则代表j当前指向的元素不大于要插入的元素，这时新元素插入j指向元素的后位就能确定顺序
			data[j + 1] = elem
		}
	}
}

func InsertSort002(data []int) {
	for i := 1; i < len(data); i++ {
		if data[i - 1] > data[i] {
			j := i - 1
			elem := data[i]
			for j >= 0 && data[j] > elem {
				data[j + 1] = data[j]
				j--
			}
			data[j + 1] = elem
		}
	}
}

func main() {
	data := []int{2, 1, 6, 8, 3, 5, 9, 4, 7}
	InsertSort001(data)
	InsertSort002(data)
	fmt.Println(data)
}
