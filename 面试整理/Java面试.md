# 1.多线程高并发编程

## 1.1.进程、线程、协程

1. 程序：存放在磁盘中的可执行的应用软件。
2. 进程：
    1. 是资源分配的基本单位；
    2. 是程序启动后从磁盘进入分配到的内存资源和代码的集合；
    3. 也是CPU指令和内存数据的集合。
3. 线程：
    1. 程序执行的基本单位；
    2. 进程中代码执行的路径；
    3. 从main线程这条路径开始执行。
4. 协程（纤程）：
    1. 线程中的多条执行路径；
    2. jvm的线程和os内核线程是1:1的关系，每启动一个线程就需要和os交互，开销大。而协程就是在用户态模拟内核级别线程的调度，在用户态的内存空间维护寄存器信息和堆信息等，这样用户级别的线程（即协程）无需和os交互就能撑起并发执行。
5. 程序的本质：
    1. 程序的本质就是CPU可以执行的汇编指令和内存中的数据；
    2. 从内存中读出PC（程序计数器）当前指向的指令地址和对应数据，通过总线写入CPU的寄存器中；
    3. CPU的ALU（逻辑计算单元）会进行计算，并将计算结果写回到内存中；
    4. 此时CPU的PC会指向下一条指令；
    5. 当CPU的核心切换到其他线程执行时，当前中断的线程相关的数据（寄存器数据，堆栈信息）会被暂存在内存中，等下次切换回来时从中断的位置继续执行。
6. 协程的应用场景：用户空间的异步编程，用于回调函数；
7. 应用程序和内核态进行交互（系统调用内核态的函数）：
    1. 应用程序发出0x80中断指令（同时发送需要调用的函数的编号和参数）或调用sysenter原语（汇编层面的原语，并非所有CPU都支持）；
    2. os进入内核态；
    3. 根据应用程序发来的编号在中断向量表中查找处理例程（即对应的内核态系统函数）；
    4. 保存硬件现场（cs，ip等寄存器值）；
    5. 保存应用程序现场（堆栈与寄存器值）；
    6. 执行中断例程system_call：
       1. 根据参数与编号寻找对应例程；
       2. 执行并返回。
    7. 恢复现场；
    8. os返回用户态；
    9. 应用程序继续执行。
8. 程序如何进行调度的：由OS操作系统完成，如Linux的线程调度器；
9. 线程切换的概念是什么：当CPU发生线程切换时，前者的执行状态会存入CPU Cache中，用于下次切换回来继续执行。
    1. 问：多线程可以提高效率，那是不是线程越多越好？
    2. 答：不是，因为更多的线程就意味着CPU要在切换下上文这个操作上面消耗更多的开销。
10. 什么是用户级别线程？什么是内核级别线程？
    1. 从java的角度来看，jvm的用户线程和操作系统的内核线程是1:1的关系；
    2. 从golang的角度来看，用户线程和内核线程是M:N的关系，而且M远远大于N；
11. golang的GPM：
     1. 自动创建一个线程池，维护一批内核线程，go关键字会将指定的任务存入任务队列中，由预先创建好的内核线程执行；
     2. 比起java，golang可以用更小的上下文切换的开销换取更大量的任务并发执行，golang的任务就相当于用户线程；
     3. 类似于java的线程池的概念，ForkJoinPool线程池，区别在于java线程池中的任务无法同步通信，而golang可以通过channel来进行任务间的同步和通信。
12. 问：有没有遇到过OOM的场景？
     重写了Object类的finalize()方法，该方法能自定义对象回收策略； 
     不断有新的对象涌入堆内存，重写的对象回收机制相当耗时，很快内存就报OOM。

## 1.2.volatile、synchronized、无锁、偏向锁、轻量级锁、重量级锁、锁升级、CAS、AQS

1. 什么是轻量级锁？什么是重量级锁？
    1. 轻量级锁又称自旋锁，需要获取被锁定的锁的线程都需要自旋等待锁的释放；
    2. 重量级锁，需要获取被锁定的锁的线程需要进入等待队列中排队，等待操作系统调度。
    3. 问：轻量级锁一定比重量级锁轻吗？或者说一定效率更高吗？不一定，如果锁的竞争非常激烈，有非常多的线程在自旋等待锁，则CPU的资源会大量消耗在Context Switch上面（即不断切换线程去执行循环操作）。



# 2.OS原理、CPU原理、Linux内核、计算机组成原理、计算机系统结构

* 操作系统内核：
  1. 什么是操作系统：一种特殊的软件，向下管理硬件系统，向上为用户提供服务，内核就是操作系统的核心逻辑；
  2. 内核的作用：以unix/linux为主，管理文件系统、管理应用调度进程、中断处理设备驱动、cpu调度、内存管理；
  3. 宏内核：kernel和其周边被其管理的如cpu调度、文件系统、内存管理等划分为一个整体，将这个整体当作操作系统的核心，称为宏内核；
  4. 微内核：kernel内核只负责进程调度，而其他如cpu调度、文件系统、内存管理等功能都可能是以分布式形式存在（不同的核心管理不同的功能），所有功能之间的交互都需要通过kernel内核进行调度，如：用户访问文件系统，需要通过kernel代理；文件系统和cpu调度交互，也需要kernel进行代理。
  5. 外内核：会根据当前运行的应用自动调整使其更适合应用程序运行；
  6. 虚拟化：通过底层的虚拟化技术管理多个虚拟的os以充分的利用硬件资源。
* 操作系统启动原理：
  1. 开机 -> 首先给主板通电 -> 主板上有一块BIOS芯片会加点自检，检测硬件的故障问题，自检完毕后加载bootloader到内存 -> 由bootloader启动操作系统（从硬盘到内存），在此之前的操作系统存储在磁盘MBR中，即磁盘的第一个扇区 -> os启动后开始接管硬件系统。
  2. 在os未启动之前，有些针对计算机硬件的设置信息，如：启动硬盘还是软盘等，会被写入到主板上的另一块芯片cmos中，这块芯片由电池供电。
* 操作系统的中断：
  1. 硬件中断信号：硬件通过发送中断信号和操作系统产生实时的交互。如键盘鼠标等设备被触发时会给os发送一个中断信号，os会中断目前正在处理的任务，根据该中断信号去os内部的中断异常处理表中查询对应的号别，根据号别做出不同的处理；
  2. 软中断：应用程序与操作系统的中断信号只有一个，也就是0x80号中断。
* 内核态和用户态：
  1. CPU指令级别：intel的cpu将指令级别划分为0、1、2、3四个级别，用于区分不同级别和优先级的指令操作；
  2. 其中os发出的都是0级指令，用户发出的都是3级指令，通过指令级别的划分，将os管理的内核态内存和用户态内存区分，即用户级别的指令操作无法访问os的内核态内存，提高了os的安全性。

* 存储器层次结构：
  1. 远程文件存储 -> 磁盘 -> 主存 -> 三级缓存 -> 二级缓存 -> 一级缓存 -> CPU寄存器；
  2. CPU高速缓存：因为CPU和内存的速度相差巨大，所有在二者中间添加了三级高速缓存做为中间层。多核CPU的每个核心都有自己独立的一级二级缓存，共用一个三级缓存；
  3. 按块读取：即从内存中一次性读取一块存入缓存中，利用空间局部性原理（如一个数组，内存空间是紧挨着的），可以提高效率，充分发挥CPU一次性读取更多数据的能力；
  4. 缓存行：越大，局部性空间效率越高，读取时间越慢；越小，局部性空间效率越低，读取时间越块；目的工业实践的结果是64byte比较合适。
  5. MESI Cache一致性协议（Intel芯片上采用的缓存一致性协议）：
     1. Modified：已修改的，一块数据存在于两颗CPU的缓存行中，若其中一个被修改则置为该状态并通知其他CPU已修改；
     2. Exclusive：独占的；
     3. Shared：共享的；
     4. Invalid：失效的，收到已修改通知的CPU需要将对应的缓存行置换为已失效状态，重新去主存读取；
     5. 注：有些无法被缓存的数据，或跨越多个缓存行的数据，依然需要使用总线锁。



# 3.从BIO、NIO、AIO、Epoll、Select到计算机网络、HTTP、TCP/IP再到Netty



# JVM



# Redis



# MySQL



# Spring



# 数据结构，算法



# 设计模式

