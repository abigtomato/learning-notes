* 问：有没有遇到过OOM的场景？
重写了Object类的finalize()方法，该方法能自定义对象回收策略； 
不断有新的对象涌入堆内存，重写的对象回收机制相当耗时，很快内存就报OOM。

* 进程，线程，协程：
    1. 程序是什么？ 
    2. 进程是什么？资源分配的基本单位。是程序启动从磁盘进入内存分配的资源和代码的集合。也是指令和数据的集合。
    3. 线程是什么？程序执行的基本单位。进程中代码执行的路径。从main线程这条路径开始执行。
    4. 程序如何开始运行？
        1. 从内存中读出PC（程序计数器）当前指向的指令和数据，通过总线存入CPU的寄存器中；
        2. CPU的ALU（逻辑计算单元）会进行计算，并将计算结果写回到内存中；
        3. 此时CPU的PC会指向下一条指令。
    5. 程序如何进行调度？由OS操作系统完成，如Linux的线程调度器；
    6. 线程切换的概念是什么？当CPU发生线程切换时，前者的执行状态会存入CPU Cache中，用于下次切换回来继续执行。
        1. 问：多线程可以提高效率，那是不是线程越多越好？不是，因为更多的线程就意味着CPU要在切换下上文这个操作上面浪费更大个开销。
    7. 什么是用户级别线程？什么是内核级别线程？
        1. 从java的角度来看，jvm的用户线程和操作系统的内核线程是1:1的关系；
        2. 从golang的角度来看，用户线程和内核线程是M:N的关系，而且M远远大于N；
    8. golang的GPM：
        1. 自动创建一个线程池，维护一批内核线程，go关键字会将指定的任务存入任务队列中，由预先创建好的内核线程执行；
        2. 比起java，golang可以用更小的上下文切换的开销换取更大量的任务并发执行，golang的任务就相当于用户线程；
        3. 类似于java的线程池的概念，ForkJoinPool线程池，区别在于java线程池中的任务无法同步通信，而golang可以通过channel来进行任务间的同步和通信。

* 锁：
    1. 什么是轻量级锁？什么是重量级锁？
        1. 轻量级锁又称自旋锁，需要获取被锁定的锁的线程都需要自旋等待锁的释放；
        2. 重量级锁，需要获取被锁定的锁的线程需要进入等待队列中排队，等待操作系统调度。
        3. 问：轻量级锁一定比重量级锁轻吗？或者说一定效率更高吗？不一定，如果锁的竞争非常激烈，有非常多的线程在自旋等待锁，则CPU的资源会大量消耗在Context Switch上面（即不断切换线程去执行循环操作）。

* 存储器层次结构：
    1. 远程文件存储 -> 磁盘 -> 主存 -> 三级缓存 -> 二级缓存 -> 一级缓存 -> CPU寄存器；
    2. 因为CPU和内存的速度相差巨大，所有在二者中间添加了三级高速缓存做为中间层；
    3. 多核CPU的每个核心都有自己独立的一级二级缓存，共用一个三级缓存；
    4. 按块读取（从内存中一次性读取一块存入缓存中）：空间局部性原理（如一个数组，内存空间是紧挨着的），可以提高效率，充分发挥总线CPU针脚等一次性读取更多数据的能力；
    5. 缓存行：越大，局部性空间效率越高，读取时间越慢；越小，局部性空间效率越低，读取时间越块；目的工业实践的结果是64byte比较合适。
    6. MESI Cache一致性协议（Intel芯片上采用的缓存一致性协议）：
        1. Modified：已修改的，一块数据存在于两颗CPU的缓存行中，若其中一个被修改则置为该状态并通知其他CPU已修改；
        2. Exclusive：独占的；
        3. Shared：共享的；
        4. Invalid：失效的，收到已修改通知的CPU需要将对应的缓存行置换为已失效状态，重新去主存读取。
        5. 注：有些无法被缓存的数据，或跨越多个缓存行的数据，依然需要使用总线锁。

* GC垃圾回收：
    1. 什么是垃圾？
    2.